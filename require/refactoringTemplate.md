# 리팩토링 계획 템플릿 v1

## 1. 프로젝트 개요

- **프로젝트명**: [프로젝트 이름]
- **현재 상태**: [현재 코드베이스의 상태와 문제점 요약]
- **리팩토링 목적**: [왜 리팩토링이 필요한지 설명]
- **기대 효과**: [리팩토링 후 예상되는 개선 사항]

## 2. 개선 대상 영역

### 2.1 코드 구조 및 아키텍처

- **현재 구조의 문제점**:

  - [문제점 1]
  - [문제점 2]

- **개선 방향**:
  - [구조 개선 방향 1]
  - [구조 개선 방향 2]

### 2.2 코드 품질 및 안정성

- **현재 이슈**:

  - [코드 품질 이슈 1]
  - [코드 품질 이슈 2]

- **개선 방향**:
  - [품질 개선 방향 1]
  - [품질 개선 방향 2]

### 2.3 사용자 인터페이스

- **현재 UI 문제점**:

  - [UI 문제점 1]
  - [UI 문제점 2]

- **개선 방향**:
  - [UI 개선 방향 1]
  - [UI 개선 방향 2]

### 2.4 성능 최적화

- **성능 이슈**:

  - [성능 이슈 1]
  - [성능 이슈 2]

- **최적화 방향**:
  - [최적화 방향 1]
  - [최적화 방향 2]

## 3. 기술적 접근 방법

### 3.1 적용할 아키텍처 패턴

- [아키텍처 패턴 1]: [세부 설명]
- [아키텍처 패턴 2]: [세부 설명]

### 3.2 사용할 기술 스택

- **언어/프레임워크**: [언어 및 주요 프레임워크]
- **라이브러리**: [주요 라이브러리 목록]
- **도구**: [개발 및 테스트 도구]

### 3.3 테스트 전략

- **테스트 범위**: [단위 테스트, 통합 테스트, UI 테스트 등]
- **테스트 도구**: [테스트에 사용할 도구]
- **커버리지 목표**: [목표 커버리지 비율]

## 4. 리팩토링 단계 및 우선순위

### 4.1 즉시 개선 사항 (1주 이내)

- [ ] [즉시 개선 작업 1]
- [ ] [즉시 개선 작업 2]
- [ ] [즉시 개선 작업 3]

### 4.2 단기 개선 사항 (1개월 이내)

- [ ] [단기 개선 작업 1]
- [ ] [단기 개선 작업 2]
- [ ] [단기 개선 작업 3]

### 4.3 장기 개선 사항 (3개월 이내)

- [ ] [장기 개선 작업 1]
- [ ] [장기 개선 작업 2]
- [ ] [장기 개선 작업 3]

## 5. 리소스 및 일정 계획

### 5.1 인력 자원

- **개발자**: [필요 개발자 수 및 역할]
- **QA**: [필요 QA 인원]
- **기타**: [필요한 기타 역할]

### 5.2 타임라인

| 단계     | 시작일 | 종료일 | 담당자   | 결과물   |
| -------- | ------ | ------ | -------- | -------- |
| [단계 1] | [날짜] | [날짜] | [담당자] | [결과물] |
| [단계 2] | [날짜] | [날짜] | [담당자] | [결과물] |
| [단계 3] | [날짜] | [날짜] | [담당자] | [결과물] |

## 6. AI 활용 계획

### 6.1 AI 도구 활용 영역

- **코드 분석**: [AI에게 요청할 코드 분석 작업]
- **코드 생성**: [AI에게 요청할 코드 생성 작업]
- **리팩토링 제안**: [AI에게 요청할 리팩토링 제안]

### 6.2 Cursor AI에 제공할 정보

- [제공 정보 1]: [정보 설명]
- [제공 정보 2]: [정보 설명]
- [제공 정보 3]: [정보 설명]

## 7. 검증 및 모니터링

### 7.1 검증 방법

- **코드 리뷰**: [코드 리뷰 프로세스]
- **테스트**: [테스트 방법론]
- **사용자 피드백**: [사용자 피드백 수집 방법]

### 7.2 성공 지표

- **코드 품질 지표**: [코드 품질 측정 방법]
- **성능 지표**: [성능 개선 측정 방법]
- **사용자 만족도**: [사용자 만족도 측정 방법]

## 8. 위험 요소 및 대응 계획

| 위험 요소 | 영향도     | 발생 가능성 | 대응 방안   |
| --------- | ---------- | ----------- | ----------- |
| [위험 1]  | [상/중/하] | [상/중/하]  | [대응 방안] |
| [위험 2]  | [상/중/하] | [상/중/하]  | [대응 방안] |
| [위험 3]  | [상/중/하] | [상/중/하]  | [대응 방안] |

## 9. 의사결정 및 승인

**승인자**: [승인자 명단]  
**결정사항**:

- [결정사항 1]
- [결정사항 2]
- [결정사항 3]

---

이 템플릿은 프로젝트 규모와 요구사항에 맞게 조정하여 사용할 수 있습니다. 모든 섹션이 모든 프로젝트에 필요한 것은 아니며, 필요에 따라 섹션을 추가하거나 제거할 수 있습니다.

--------------



# 📄 Refactoring Requirements v2 (simple)

이 문서는 코드의 유지보수성과 확장성을 높이기 위해 필요한 리팩토링 요구사항을 정리한 문서입니다.  
Cursor 또는 AI 도구가 이 내용을 기반으로 리팩토링 계획을 세우는 데 참고하도록 구성되어 있습니다.

---

## 📌 대상 파일
- `UserProfileViewModel.kt`

---

## 🛠️ 리팩토링 목적
- 유지보수성이 낮은 구조 개선
- 중복 코드 제거
- 테스트 용이성 향상
- 함수별 책임 명확화
- 다국어 대응 로직 분리

---

## 🔍 현재 문제점 요약
- 함수 길이가 지나치게 김 (`loadUserData`가 120줄 이상)
- `when` 블록이 중첩되어 가독성 저하
- 동일한 `try-catch` 구조가 3군데 이상 반복됨
- 비즈니스 로직과 뷰 업데이트 로직이 혼재되어 있음
- 유닛 테스트 작성이 어려운 구조

---

## ✅ 리팩토링 요구사항 상세

1. **함수 분리**
   - 100줄 이상 함수 → 최대 30줄 이하로 분리
   - 각 블록의 역할 단위로 함수로 나눌 것

2. **공통 예외 처리 분리**
   - 중복된 `try-catch` 블록 → 공통 처리 유틸로 이동
   - 로그 메시지 일관성 확보

3. **책임 분리 (SRP 적용)**
   - 데이터 처리와 UI 처리 코드 분리
   - UI 상태 갱신은 별도의 함수에서 수행

4. **조건문 개선**
   - `when` 중첩 → Enum 또는 Strategy 패턴으로 리팩토링 고려

5. **테스트 작성 고려**
   - 각 분리된 함수는 유닛 테스트 가능한 구조로 만들 것
   - ViewModel 테스트 작성이 용이하도록 의존성 주입 방식 유지

---

## 🧩 기타 참고 정보

- Kotlin + MVVM 구조
- Jetpack Compose 기반 화면 구성
- ViewModel에서 Repository 호출 → UI 상태 emit 방식 사용 중

---

## 🔖 문서 사용 방법
이 문서를 Cursor 등 AI 도구에 함께 입력하여,
`위 요구사항을 기반으로 리팩토링 계획을 수립해주세요` 라고 요청합니다.